📊 프로젝트 특성 분석

최근 대화를 검토한 결과, 이 프로젝트는 다음과 같은 특징이 있습니다:

- 기술 스택: Java 8 (Zulu), Spring, Maven, MyBatis, MS-SQL/PostgreSQL, Tomcat 9, RealGrid/JQGrid
- 개발 환경: Windows, IntelliJ IDEA/STS, GitHub Desktop
- 주요 업무: 인사관리 시스템 유지보수, 데이터 검증, 배포, 기술 문제 해결

---


🎯 실행 규칙

📐 10가지 핵심 공식(변수만 해당)

| # | 공식 | 주요 변수 |
| -- | | |
| 1 | 천재적 통찰력 | GI = (관찰 × 연결 × 패턴 × 통합) / (가정 + 편견) |
| 2 | 다차원 | 5가지 차원: 시간-공간-추상화-인과관계-위계 |
| 3 | 창의적 연결 | 직접 - 간접 - 역설 - 은유 - 시스템 연결 |
| 4 | 문제 재정의 | 180° 뒤집기 - 스케일 이동 - 개념 이동 - 도메인 이동
| 5 | 혁신 솔루션 | 결합-차용-제약→우위-역발상-시스템 재설계
| 6 | 통찰력 증폭 | 5가지 이유 - 만약에 - 어떻게 할 수 있을까?
| 7 <사고의 진화> 학습-경험-성찰-교환-실패 학습
| 8 | 복잡성 해결 | 분해 → 관계 매핑 → 레버리지 포인트 |
| 9 | 직관적 도약 | (침묵 × 경험 × 신뢰) / (논리 × 합리화) |
| 10 | 통합적 지혜 | (지식 + 이해 + 지혜 + 연민 + 행동) × 겸손 × 윤리 |


# 🎯 프로젝트별 맞춤 지침 (Project-Specific Guidelines)

🔧 1. 기술 스택 전문 지침

Java/Spring 프로젝트 관리
- 스레드풀 관리: ThreadPoolTaskScheduler 사용 시 반드시 `@PreDestroy`로 종료 처리 구현
- 메모리 누수 방지: JDBC 드라이버, 스케줄러 정리 로직 필수 포함
- 빌드 설정: Maven 프로파일(dev/uat/prod) 명확히 구분하여 관리

그리드 UI 데이터 검증
- 필수 컬럼 검증: 그리드 로딩 후 `requestAnimationFrame`으로 타이밍 보장하여 누락 데이터 체크
- 사용자 피드백: 누락 데이터 발견 시 구체적인 행 번호와 건수를 경고창에 표시
- 포커스 이동: 첫 번째 문제 행으로 자동 포커스하여 즉시 수정 가능하도록 구현

MyBatis XML 작업
- 쿼리 최적화: 파라미터 바인딩 시 `#{}` 우선 사용, SQL 인젝션 방지
- 동적 쿼리: `<if>`, `<choose>` 태그로 조건부 쿼리 구성
- 결과 매핑: resultType보다 resultMap 활용하여 명시적 매핑 선호

---

🛠️ 2. 개발 도구 활용 지침

IntelliJ IDEA 워크플로우
- 프로젝트 Import: `File → Open → pom.xml` 선택으로 Maven 프로젝트 가져오기
- Tomcat 연동: `Run → Edit Configurations → Tomcat Server → Local`에서 설정
- 디버깅: `Shift+F9`로 디버그 모드 실행, 브레이크포인트(`Ctrl+F8`)로 변수 추적
- 빠른 탐색: `Ctrl+Shift+F`(전체 검색), `Ctrl+N`(클래스 찾기), `Ctrl+Shift+N`(파일 찾기)
- Hot Swap: JSP/HTML/CSS는 저장만으로 반영, Java는 `Ctrl+F9`로 빌드

GitHub Desktop 협업
- 브랜치 전략: feature → develop → release → main 순서 유지
- PR 프로세스: Push → GitHub 웹에서 "Merge pull request" → develop에 반영 확인
- 충돌 해결: Fetch → Merge → 충돌 해결 → Commit → Push 순서
- Repository 위치 변경: `Repository → Repository settings → Local Path 변경`

---

📋 3. 코드 작성 및 수정 표준

기존 코드 수정 시
- 삭제 금지 원칙: 기존 로직은 보존하고 새 기능만 추가 (주석 처리 허용)
- 테스트 우선: analysis tool로 로직 검증 후 artifact 생성
- 주석 명확화: 왜(Why) 이렇게 구현했는지 설명 (무엇(What)이 아닌)

에러 처리 패턴

// 권장: 구체적 예외 처리
try {
    // 로직
} catch (SQLException e) {
    log.error("DB 조회 실패: 테이블={}, 파라미터={}", tableName, params, e);
    throw new CustomException("데이터 조회 중 오류 발생", e);
}


SQL 작성 규칙

<!-- MyBatis: 파라미터 타입 명시 -->
<select id="selectUser" parameterType="map" resultType="UserVO">
    SELECT user_id, user_name 
    FROM users
    WHERE dept_name = #{deptName}
      AND status = 'ACTIVE'
</select>


---

🚀 4. 배포 및 운영 지침

로컬 테스트 체크리스트
- [ ] Maven clean compile 성공
- [ ] Tomcat 정상 기동 (8080 포트)
- [ ] 로그에서 에러/경고 확인
- [ ] 수정 화면 접속 및 기능 테스트
- [ ] DB 커넥션 정상 (로그 확인)

Tomcat 배포 절차
1. `mvn clean package -P{profile}` 실행
2. WAR 파일 생성 확인 (`target/` 폴더)
3. Tomcat 중지 → WAR 교체 → 재시작
4. `catalina.out` 로그에서 에러 체크
5. 헬스체크 엔드포인트 호출 (예: `/health`)

에러 발생 시 대응
- "Page not found": URL 매핑(`@RequestMapping`) 확인 → JSP 경로 확인
- "Data not loaded": SQL 쿼리 실행 → 파라미터 바인딩 → DB 직접 조회
- "Memory leak": ThreadPoolTaskScheduler 종료 로직 → JDBC 드라이버 정리

---

🧪 5. 문제 해결 방법론

단계별 디버깅 프로세스
1. 재현: 사용자 신고 → 로컬에서 동일 상황 재현
2. 로그 추적: 콘솔/파일 로그에서 스택 트레이스 확인
3. 코드 탐색: `Ctrl+Shift+F`로 에러 메시지 검색 → 해당 파일 열기
4. 브레이크포인트: Controller → Service → DAO → SQL 순으로 변수값 추적
5. 수정: 문제 지점 수정 → 로컬 테스트 → 커밋

자주 발생하는 문제 패턴
| 문제 유형 | 체크 포인트 | 해결 방법 |
|---------|----------|---------|
| NullPointerException | 객체 초기화, Optional 사용 | 방어적 코딩, null 체크 추가 |
| SQLException | 쿼리 문법, 테이블/컬럼명 | DB 직접 실행으로 검증 |
| 404 Error | URL 매핑, JSP 경로 | `@RequestMapping` 확인 |
| Memory Leak | 스레드풀 미종료 | `@PreDestroy` 구현 |

---

📝 6. 문서화 및 보고 표준

작업 완료 보고 템플릿

# 작업 완료 보고서
작업명: [기능명]
대상 파일: [Controller/Service/Mapper 경로]
주요 변경사항:
- Before: [기존 동작]
- After: [변경 후 동작]
테스트 결과:
- [ ] 로컬 테스트 완료
- [ ] 배포 후 검증 완료
영향 범위: [관련 화면/기능 목록]


코드 리뷰 요청 시
- 변경 이유(Why) 명확히 설명
- Before/After 스크린샷 첨부
- 테스트 시나리오 공유

---

⚙️ 7. 성능 최적화 지침

그리드 성능 개선
- 대용량 데이터는 페이징 처리 (1,000건 이상)
- Virtual Scrolling 활용
- 불필요한 컬럼 숨김 처리

SQL 쿼리 최적화

-- 인덱스 활용 확인
EXPLAIN SELECT * FROM users WHERE dept_name = 'IT';

-- N+1 문제 방지
SELECT u.*, d.dept_name 
FROM users u 
LEFT JOIN departments d ON u.dept_id = d.dept_id;


메모리 관리
- 대용량 파일 업로드 시 스트림 처리
- Connection Pool 크기 적정 유지 (10~50)
- Static 변수 남용 금지

---

🎓 범용 지침과의 차별점

| 구분 | 범용 지침 | 프로젝트별 지침 |
|------|----------|---------------|
| 적용 대상 | 모든 대화 | 현재 프로젝트만 |
| 내용 | 답변 품질, 신뢰성, 언어 규칙 | 기술 스택, 도구, 워크플로우 |
| 예시 | "불확실하면 '잘 모름' 표시" | "IntelliJ에서 Ctrl+Shift+F로 검색" |
| 업데이트 | 거의 고정 | 프로젝트 진행에 따라 변경 |

---

✅ 체크리스트: 이 지침을 따르고 있는가?

매 작업 시작 전:
- [ ] 범용 지침(신뢰성/검증)은 항상 적용되는가?
- [ ] 프로젝트별 기술 스택(Java 8/Spring/MyBatis)을 고려했는가?
- [ ] IntelliJ/GitHub Desktop 사용법을 정확히 안내했는가?
- [ ] 기존 코드는 보존하면서 추가만 했는가?

작업 완료 후:
- [ ] 로컬 테스트를 완료했는가?
- [ ] 에러 로그를 확인했는가?
- [ ] 보고서 템플릿에 맞춰 작성했는가?

---

📌 주요 원칙 요약

1. 기존 코드 보존: 삭제하지 말고 추가만
2. 도구 활용: IntelliJ 단축키, GitHub Desktop UI 경로 명확히
3. 검증 우선: analysis tool 테스트 → artifact 생성
4. 구체적 보고: "안 됨" X → "어떤 상황에서 어떤 에러" O
5. 성능 고려: 그리드 페이징, SQL 최적화, 메모리 관리

---
