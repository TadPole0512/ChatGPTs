🎯 프로젝트별 맞춤 지침

📋 프로젝트 특성 분석

프로젝트 도메인: 미디어 자동화 & PowerShell/Python 스크립팅  
주요 작업 패턴:
1. Windows 환경 자동화 스크립트 개발 (PowerShell + Python)
2. 미디어 파일 처리 (동영상/이미지 중복 탐지, 다운로드)
3. CLI 도구 개발 및 최적화
4. 오류 처리 및 로깅 시스템 구축

---


🎯 실행 규칙

📐 10가지 핵심 공식(변수만 해당)

| # | 공식 | 주요 변수 |
| -- | | |
| 1 | 천재적 통찰력 | GI = (관찰 × 연결 × 패턴 × 통합) / (가정 + 편견) |
| 2 | 다차원 | 5가지 차원: 시간-공간-추상화-인과관계-위계 |
| 3 | 창의적 연결 | 직접 - 간접 - 역설 - 은유 - 시스템 연결 |
| 4 | 문제 재정의 | 180° 뒤집기 - 스케일 이동 - 개념 이동 - 도메인 이동
| 5 | 혁신 솔루션 | 결합-차용-제약→우위-역발상-시스템 재설계
| 6 | 통찰력 증폭 | 5가지 이유 - 만약에 - 어떻게 할 수 있을까?
| 7 <사고의 진화> 학습-경험-성찰-교환-실패 학습
| 8 | 복잡성 해결 | 분해 → 관계 매핑 → 레버리지 포인트 |
| 9 | 직관적 도약 | (침묵 × 경험 × 신뢰) / (논리 × 합리화) |
| 10 | 통합적 지혜 | (지식 + 이해 + 지혜 + 연민 + 행동) × 겸손 × 윤리 |


# 🆕 신규 프로젝트 지침 (범용 지침과 비중복)


🎬 미디어 자동화 프로젝트 전용 지침 v1.0

🔧 A. PowerShell 스크립트 개발 표준

A1. 스크립트 헤더 필수 요소
- `#Requires -Version 5.1` 명시
- `.SYNOPSIS`, `.DESCRIPTION`, `.NOTES` 포함
- 버전 이력(CHANGELOG) 주석 유지
- 매개변수 검증: `[ValidateSet]`, `[Parameter(Mandatory)]`

A2. 오류 처리 계층

# 레벨 1: 전역 설정
$ErrorActionPreference = "Stop"

# 레벨 2: 함수별 try-catch-finally
try {
    # 핵심 로직
} catch {
    Write-Warning "[$FunctionName] 오류: $($_.Exception.Message)"
    # 로그 기록
} finally {
    # 리소스 정리
}

# 레벨 3: 재시도 로직 (네트워크/외부 도구)
$maxRetries = 3
for ($i = 1; $i -le $maxRetries; $i++) {
    # 시도 로직
}


A3. 외부 프로세스 호출 안전장치
- 타임아웃 설정: `-TimeoutSec` 또는 `Start-Process -Wait -NoNewWindow`
- 종료 코드 검증: `$LASTEXITCODE`
- 표준출력/에러 분리: `2>&1` 리다이렉션 또는 `$ErrorActionPreference = "Continue"`

A4. 배열/컬렉션 처리 주의사항
- 명령줄 배열 전달: `'item1','item2'` (PowerShell 7+에서 `@()` 회피)
- 안전한 슬라이싱: `if ($array.Count -gt 0) { ... }`
- 타입 명시: `[string[]]$arr = @()`

---

🐍 B. Python 미디어 처리 스크립트 표준

B1. 프로젝트 구조 템플릿

script_name.py
├── 설정 영역 (CONFIG 딕셔너리)
├── 의존성 체크 함수
├── 헬퍼 함수 (메타데이터 추출, 해싱 등)
├── 핵심 처리 로직 (클래스 기반)
├── CLI 파서 (argparse)
└── main() 진입점


B2. FFmpeg/FFprobe 통합 패턴

def find_ffprobe():
    """경로 자동 탐지 → 사용자 안내 순서"""
    for cmd in ['ffprobe', 'ffprobe.exe']:
        if shutil.which(cmd):
            return cmd
    # 설치 안내 메시지
    raise EnvironmentError("FFprobe를 찾을 수 없습니다...")

def get_video_metadata(path: str) -> Dict:
    """타임아웃, JSON 파싱, 예외 처리 포함"""
    cmd = [find_ffprobe(), '-v', 'error', '-of', 'json', ...]
    result = subprocess.run(cmd, capture_output=True, text=True, timeout=10)
    return json.loads(result.stdout)


B3. 멀티프로세싱 안전 규칙
- 로컬 함수 금지 → 모듈 레벨 함수로 분리
- `if __name__ == "__main__":` 가드 필수
- Windows: `multiprocessing.freeze_support()` 추가
- 인자 직렬화: 기본 타입(str, int, tuple) 사용

B4. 캐시 시스템 구현

# 픽클 캐시 with 안전 쓰기
def save_cache(data, cache_file):
    tmp = cache_file.with_suffix('.tmp')
    with open(tmp, 'wb') as f:
        pickle.dump(data, f)
    tmp.replace(cache_file)  # 원자적 교체

# 캐시 유효성 검사
def is_cache_valid(cache_path, max_age_hours=24):
    if not cache_path.exists():
        return False
    age = time.time() - cache_path.stat().st_mtime
    return age < (max_age_hours * 3600)


---

📊 C. 미디어 파일 처리 최적화

C1. 대용량 파일 스캔 전략
1. 1차 필터: 파일 크기/확장자 (빠름)
2. 2차 필터: 메타데이터 (ffprobe, Pillow)
3. 3차 분석: 콘텐츠 해시 (느림, 후보만 처리)

C2. 해시 알고리즘 선택
- 완전 중복: `hashlib.sha256()` (전체 파일)
- 유사 이미지: `imagehash.phash()` (pHash)
- 유사 동영상: 프레임 샘플링 + pHash 평균

C3. 진행률 표시 패턴

from tqdm import tqdm

# 간단한 진행률
for item in tqdm(items, desc="처리 중", unit="파일"):
    process(item)

# 중첩 진행률
for user in tqdm(users, desc="사용자", position=0):
    for file in tqdm(files, desc=f"@{user}", position=1, leave=False):
        download(file)


C4. 격리(Quarantine) 폴더 관리
- 원본 디렉토리 구조 보존
- 메타데이터 JSON 생성 (원본 경로, 이동 시각, 해시)
- 롤백 스크립트 자동 생성 (PowerShell/Bash)

---

🔒 D. 외부 도구 통합 안전성

D1. gallery-dl 통합 체크리스트
- [ ] 쿠키 파일 존재 확인 (`Test-Path`)
- [ ] 종료 코드 해석 (0=성공, 4=쿠키만료, 16=Rate Limit)
- [ ] `--exec` 페이로드를 단일 배열 요소로 전달
- [ ] `--jobs` 위치: URL 직전 배치
- [ ] `--download-archive` 활용 (증분 다운로드)

D2. Rate Limit 회피 전략

# 요청 간 대기
-SleepRequest 1.5  # API 호출 간격
-Sleep 3           # 파일 다운로드 간격

# 실패 시 지수 백오프
$delay = [Math]::Pow(2, $retryCount) * $baseDelay
Start-Sleep -Seconds $delay


---

📝 E. 로깅 및 리포트 작성

E1. 3단계 로그 구조
1. 세션 로그: 실행 전체 흐름 (`session_YYYYMMDD_HHMMSS.log`)
2. 항목별 로그: 사용자/파일당 상세 (`users/@username/_errors.log`)
3. 요약 JSON: 기계 읽기 가능 통계 (`summary.json`)

E2. 로그 메시지 포맷

# 계층적 컨텍스트 표시
logging.info(f"[사용자: {username}] [파일: {filename}] 다운로드 시작")

# 진행률 포함
logging.info(f"[{current}/{total}] 처리 중... ({percent:.1f}%)")

# 오류 시 액션 가이드
logging.error(f"쿠키 만료 감지. 다음 명령 실행: gallery-dl --cookies-from-browser chrome ...")


E3. CSV 리포트 필수 컬럼

# 중복 탐지 리포트
columns = [
    'group_id',      # 그룹 식별자
    'file_a',        # 원본 경로
    'file_b',        # 중복 후보 경로
    'similarity',    # 유사도 점수 (0.0~1.0)
    'reason',        # 판정 근거 (metadata/phash/audio)
    'size_diff_mb',  # 파일 크기 차이
    'duration_diff', # 재생 시간 차이
    'action'         # 권장 조치 (keep/quarantine)
]


---

⚙️ F. CLI 설계 원칙

F1. 매개변수 우선순위
1. 명령줄 인자 (최우선)
2. 환경 변수 (`$env:VAR_NAME`)
3. 설정 파일 (`config.json`)
4. 하드코딩 기본값

F2. 필수 옵션 설계

parser = argparse.ArgumentParser(
    description="미디어 처리 도구",
    epilog="예시: python script.py --root D:\\Videos --dry-run"
)

# 필수 그룹
required = parser.add_argument_group('required arguments')
required.add_argument('--root', required=True, help="루트 디렉토리")

# 모드 선택
mode = parser.add_mutually_exclusive_group()
mode.add_argument('--dry-run', action='store_true', help="시뮬레이션만")
mode.add_argument('--quarantine', metavar='DIR', help="격리 폴더 지정")


F3. 디버그 모드 전환

# PowerShell
-Verbose         # 상세 출력
-Debug           # 중단점 활성화
-Echo            # 명령어 출력 (실행 전)

# Python
--log-level DEBUG
--show-progress   # tqdm 활성화
--echo-commands   # subprocess 명령 출력


---

🧪 G. 테스트 및 검증

G1. 샘플 데이터셋 구성

test_data/
├── duplicates/
│   ├── video_original.mp4
│   ├── video_reencoded.mp4   # 동일 내용, 다른 인코딩
│   └── video_trimmed.mp4      # 일부 편집
├── unique/
│   ├── movie_a.mkv
│   └── movie_b.mkv
└── edge_cases/
    ├── corrupted.avi          # 손상 파일
    ├── very_short.mp4         # <5초
    └── audio_only.mp3         # 오디오 전용


G2. 자동 검증 스크립트

def validate_results(output_csv, expected_pairs):
    """리포트 파일과 예상 결과 비교"""
    df = pd.read_csv(output_csv)
    
    # True Positive: 정확히 탐지
    tp = len(df[df['file_a'].isin(expected_pairs)])
    
    # False Positive: 오탐
    fp = len(df[~df['file_a'].isin(expected_pairs)])
    
    precision = tp / (tp + fp) if (tp + fp) > 0 else 0
    print(f"Precision: {precision:.2%}")


---

🎓 H. 문제 해결 패턴북

H1. 일반적인 오류와 해결책

| 오류 | 원인 | 해결 |
|------|------|------|
| `Can't get local object` | 멀티프로세싱 직렬화 실패 | 함수를 모듈 레벨로 이동 |
| `Access denied C:\Windows\System32` | 잘못된 작업 디렉토리 | `cd` 명령으로 스크립트 위치 이동 |
| `unrecognized arguments: --jobs` | 매개변수 파싱 순서 오류 | `--jobs`를 URL 직전으로 이동 |
| `Exit Code 4` (gallery-dl) | 쿠키 만료 | `--cookies-from-browser` 재추출 |
| `Rate Limit Exceeded` | 과다 요청 | Sleep 값 증가 (3→10초) |

H2. 성능 병목 진단

import time
from functools import wraps

def profile(func):
    @wraps(func)
    def wrapper(*args, kwargs):
        start = time.time()
        result = func(*args, kwargs)
        duration = time.time() - start
        logging.info(f"{func.__name__} 실행 시간: {duration:.2f}초")
        return result
    return wrapper

@profile
def process_video(path):
    # 처리 로직
    pass


---

🔄 I. 프로젝트 워크플로우 템플릿

I1. 신규 스크립트 개발 순서
1. 요구사항 분석 → 범위/제약/목표 명확화
2. 외부 의존성 확인 → ffmpeg, gallery-dl 등
3. 드라이런 모드 구현 → 안전성 우선
4. 캐시 시스템 추가 → 재실행 최적화
5. 오류 처리 강화 → 재시도/로깅
6. CLI 인터페이스 완성 → argparse/parameter
7. 문서화 → 헤더 주석 + README

I2. 버전 업그레이드 체크리스트
- [ ] CHANGELOG 업데이트
- [ ] 버전 번호 증가 (`VERSION` 변수)
- [ ] 하위 호환성 확인
- [ ] 기존 캐시 파일 마이그레이션
- [ ] 테스트 데이터로 검증

---

📐 J. 코드 품질 가이드라인

J1. 변수 네이밍 규칙

# 파일/경로
video_path, input_dir, output_file

# 카운터/인덱스
file_count, current_idx, retry_num

# 플래그
is_cached, has_error, should_skip

# 설정
MAX_RETRIES, TIMEOUT_SECONDS, CACHE_EXPIRY_HOURS


J2. 함수 크기 제한
- 한 함수당 50줄 이하 목표
- 중첩 깊이 3단계 이하
- 단일 책임 원칙 (SRP) 준수

J3. 주석 스타일

# ✅ Good: 왜(Why)를 설명
# 손상된 파일은 메타데이터 추출 실패하므로 스킵
if is_corrupted(path):
    continue

# ❌ Bad: 무엇(What)을 반복
# 손상된 파일이면 continue
if is_corrupted(path):
    continue


---


---

# 📘 설명 (지침과 구분)

🎯 신규 지침의 차별화 포인트

위의 프로젝트별 지침은 다음과 같은 특징으로 범용 지침과 중복을 최소화했습니다:

1️⃣ 도메인 특화
- 범용: 웹 개발, 천재적 사고, 질문 처리 일반 원칙
- 프로젝트: Windows 미디어 자동화, PowerShell/Python 스크립팅에만 집중

2️⃣ 구체적 도구 통합
- FFmpeg/FFprobe, gallery-dl, imagehash 등 실제 사용 중인 도구의 안티패턴과 해결책 명시
- 범용 지침에는 없는 외부 프로세스 호출, 멀티프로세싱, 캐시 전략 구체화

3️⃣ 실전 문제 해결
- 프로젝트 대화 기록에서 반복되는 오류 패턴 추출:
  - `Can't get local object` (멀티프로세싱)
  - `Access denied System32` (작업 디렉토리)
  - gallery-dl Exit Code 해석
  
4️⃣ 워크플로우 최적화
- 드라이런 → 캐시 → 격리 → 롤백 순서의 프로젝트 특유 작업 흐름 정리
- 범용 지침의 추상적 단계별 처리를 미디어 처리 컨텍스트로 구체화

---

📊 범용 vs 프로젝트 지침 비교표

| 항목 | 범용 지침 | 프로젝트 지침 |
|------|-----------|----------------|
| 대상 | 모든 프로젝트 | Windows 미디어 자동화만 |
| 언어 | Java, C#, JS, Python 일반 | PowerShell + Python 미디어 처리 |
| 도구 | Spring, .NET, Express 일반론 | FFmpeg, gallery-dl, imagehash |
| 오류 처리 | 일반적 try-catch 패턴 | 재시도/타임아웃/Rate Limit 구체화 |
| 성능 | 코드 스플리팅, 캐싱 추상화 | 프레임 샘플링, 픽클 캐시, 멀티프로세싱 |
| 예시 | 개념적 pseudo-code | 실제 작동하는 PowerShell/Python 스니펫 |

---

🚀 활용 방법

📁 권장 지침 저장 위치

프로젝트_루트/
├── .guidelines/
│   ├── README.md                   👈 이 문서 (프로젝트 전용)
│   └── common_guidelines.md         (범용 지침 참조용)
└── scripts/
    ├── get_x_media_*.ps1
    └── dup_video_*.py


💡 지침 적용 시나리오

시나리오 1: 새 PowerShell 스크립트 작성 시
1. 범용 지침: Rules_en (질문 분해, 단계별 처리)
2. 프로젝트 지침: 섹션 A (PowerShell 표준), D (외부 도구 통합)

시나리오 2: Python 미디어 처리 버그 수정 시
1. 범용 지침: Trust-Validation (추측 구분, 출처 명시)
2. 프로젝트 지침: 섹션 B (Python 표준), H (문제 해결 패턴북)

시나리오 3: 성능 최적화 요청 시
1. 범용 지침: developer_guide (성능 체크리스트)
2. 프로젝트 지침: 섹션 C (미디어 처리 최적화), H2 (병목 진단)

---

🔄 지침 유지보수 계획

주기적 업데이트 트리거
- [ ] 동일 오류 3회 이상 반복 → 패턴북 추가
- [ ] 새 도구 도입 (예: yt-dlp) → 통합 체크리스트 작성
- [ ] 성능 개선 발견 시 → 최적화 섹션 업데이트
- [ ] 분기별 대화 기록 리뷰 → 누락된 패턴 반영

버전 관리

프로젝트 지침 버전 이력
- v1.0 (2025-10-10): 초기 작성
- v1.1 (예정): yt-dlp 통합 섹션 추가
- v1.2 (예정): GPU 가속 동영상 처리 패턴 추가


---

✅ 최종 체크리스트

지침 완성도 확인
- [x] 범용 지침과 중복 내용 제거
- [x] 프로젝트 특화 도구/패턴 포함
- [x] 실전 코드 예시 포함 (pseudo-code 아님)
- [x] 문제 해결 패턴북 작성
- [x] 워크플로우 템플릿 제공
- [x] 명확한 섹션 구분 (A~J)

사용성 확인
- [x] 목차로 빠른 탐색 가능
- [x] 테이블로 정보 요약
- [x] 실행 가능한 코드 스니펫
- [x] 범용 지침과의 관계 명시

---
